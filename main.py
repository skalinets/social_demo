import time
import redis
import uuid
import math


def acquire_lock_with_timeout(conn, lockname, acquire_timeout=10, lock_timeout=10):
    identifier = str(uuid.uuid4())  # A
    lockname = "lock:" + lockname
    lock_timeout = int(math.ceil(lock_timeout))  # D

    end = time.time() + acquire_timeout
    while time.time() < end:
        if conn.setnx(lockname, identifier):  # B
            conn.expire(lockname, lock_timeout)  # B
            return identifier
        elif conn.ttl(lockname) < 0:  # C
            conn.expire(lockname, lock_timeout)  # C

        time.sleep(0.001)

    return False


def to_bytes(x):
    return x.encode() if isinstance(x, str) else x


def to_str(x):
    return x.decode() if isinstance(x, bytes) else x


def release_lock(conn, lockname, identifier):
    pipe = conn.pipeline(True)
    lockname = "lock:" + lockname
    identifier = to_bytes(identifier)

    while True:
        try:
            pipe.watch(lockname)  # A
            if pipe.get(lockname) == identifier:  # A
                pipe.multi()  # B
                pipe.delete(lockname)  # B
                pipe.execute()  # B
                return True  # B

            pipe.unwatch()
            break

        except redis.WatchError:  # C
            pass  # C

    return False  # D


CONFIGS = {}
CHECKED = {}


def create_user(conn, login, name):
    llogin = login.lower()
    lock = acquire_lock_with_timeout(conn, "user:" + llogin, 1)  # A
    if not lock:  # B
        return None  # B

    if conn.hget("users:", llogin):  # C
        release_lock(conn, "user:" + llogin, lock)  # C
        return None  # C

    id = conn.incr("user:id:")  # D
    pipeline = conn.pipeline(True)
    pipeline.hset("users:", llogin, id)  # E
    pipeline.hmset(
        "user:%s" % id,
        {  # F
            "login": login,  # F
            "id": id,  # F
            "name": name,  # F
            "followers": 0,  # F
            "following": 0,  # F
            "posts": 0,  # F
            "signup": time.time(),  # F
        },
    )
    pipeline.execute()
    release_lock(conn, "user:" + llogin, lock)  # G
    return id  # H


# <end id="create-twitter-user"/>
# A Try to acquire the lock for the lowercased version of the login name. This function is defined in chapter 6
# B If we couldn't get the lock, then someone else already has the same login name
# C We also store a HASH of lowercased login names to user ids, so if there is already a login name that maps to an ID, we know and won't give it to a second person
# D Each user is given a unique id, generated by incrementing a counter
# E Add the lowercased login name to the HASH that maps from login names to user ids
# F Add the user information to the user's HASH
# G Release the lock over the login name
# H Return the id of the user

def create_status(conn, uid, message, **data):
    pipeline = conn.pipeline(True)
    pipeline.hget('user:%s'%uid, 'login')   #A
    pipeline.incr('status:id:')             #B
    login, id = pipeline.execute()

    if not login:                           #C
        return None                         #C

    data.update({
        'message': message,                 #D
        'posted': time.time(),              #D
        'id': id,                           #D
        'uid': uid,                         #D
        'login': login,                     #D
    })
    pipeline.hmset('status:%s'%id, data)    #D
    pipeline.hincrby('user:%s'%uid, 'posts')#E
    pipeline.execute()
    return id                               #F
# <end id="create-twitter-status"/>
#A Get the user's login name from their user id
#B Create a new id for the status message
#C Verify that we have a proper user account before posting
#D Prepare and set the data for the status message
#E Record the fact that a status message has been posted
#F Return the id of the newly created status message
